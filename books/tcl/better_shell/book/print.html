<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tcl As A Better Shell</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li class="chapter-item expanded "><a href="why_tcl_now.html"><strong aria-hidden="true">2.</strong> なぜ今さらTcl?</a></li><li class="chapter-item expanded "><a href="environment.html"><strong aria-hidden="true">3.</strong> 本書の環境</a></li><li class="chapter-item expanded "><a href="evaluation_rule.html"><strong aria-hidden="true">4.</strong> Tcl インタープリターと評価のルール</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tcl_command.html"><strong aria-hidden="true">4.1.</strong> コマンド</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="command_command_command.html"><strong aria-hidden="true">4.1.1.</strong> コマンドという語の多義性</a></li><li class="chapter-item expanded "><a href="tcl_list.html"><strong aria-hidden="true">4.1.2.</strong> word列と Tcl リスト</a></li></ol></li><li class="chapter-item expanded "><a href="comment.html"><strong aria-hidden="true">4.2.</strong> コメント</a></li><li class="chapter-item expanded "><a href="tcl_wordbreaking.html"><strong aria-hidden="true">4.3.</strong> インタープリタとコマンドのword分割</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="puts.html"><strong aria-hidden="true">4.3.1.</strong> puts stdout</a></li><li class="chapter-item expanded "><a href="word_breaking_and_quoting.html"><strong aria-hidden="true">4.3.2.</strong> word分割とquote</a></li></ol></li><li class="chapter-item expanded "><a href="substitution.html"><strong aria-hidden="true">4.4.</strong> word内の置換</a></li><li class="chapter-item expanded "><a href="arg_expansion.html"><strong aria-hidden="true">4.5.</strong> wordの展開</a></li><li class="chapter-item expanded "><a href="tcl_interp_overall.html"><strong aria-hidden="true">4.6.</strong> インタープリタの役割（まとめ）</a></li><li class="chapter-item expanded "><a href="quote.html"><strong aria-hidden="true">4.7.</strong> quoteと置換の細かい話</a></li></ol></li><li class="chapter-item expanded "><a href="proc_expr_control.html"><strong aria-hidden="true">5.</strong> 変数、手続き、計算式、制御構文</a></li><li class="chapter-item expanded "><strong aria-hidden="true">6.</strong> XXX: 名前空間</li><li class="chapter-item expanded "><strong aria-hidden="true">7.</strong> XXX: データ型とコマンド</li><li><ol class="section"><li class="chapter-item expanded "><strong aria-hidden="true">7.1.</strong> XXX: TclObjと内部表現</li><li class="chapter-item expanded "><strong aria-hidden="true">7.2.</strong> XXX: リスト</li><li class="chapter-item expanded "><strong aria-hidden="true">7.3.</strong> XXX: 文字列</li><li class="chapter-item expanded "><strong aria-hidden="true">7.4.</strong> XXX: 数値</li><li class="chapter-item expanded "><strong aria-hidden="true">7.5.</strong> XXX: ファイルとプロセス</li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">8.</strong> XXX: サブ・インタープリター</li><li class="chapter-item expanded "><strong aria-hidden="true">9.</strong> XXX: snit</li><li class="chapter-item expanded "><a href="appendix.html"><strong aria-hidden="true">10.</strong> 付録</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="comparison_with_bash.html"><strong aria-hidden="true">10.1.</strong> bashとの比較</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Tcl As A Better Shell</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#はじめに" id="はじめに">はじめに</a></h1>
<p>この文書は、他のプログラミング言語の経験者のための、Tcl と snit の入門書です。想定する読者は</p>
<ul>
<li>端末で bash や zsh などに触れた経験があり、</li>
<li>OOP 言語の使用経験が有る</li>
</ul>
<p>方々です。</p>
<p>本書の構成・例題は部分的に
<a href="http://www.beedub.com/book/">Practical Programming in Tcl and Tk</a>
（邦訳 <a href="https://www.kinokuniya.co.jp/f/dsg-01-9784894710856">Tcl・Tk入門</a>）を参考にしています。ただ、前掲書は古いバージョンの Tcl を前提としているため、
今から Tcl を学ぶ人にはお勧めしづらい面があります。</p>
<p>この文書の第一のテーマは、Tcl8.5 に対応した、 <strong>そこそこモダンな Tcl</strong> の書き方を
解説することです。Tcl は 8.5 で <code>{*}</code> 構文の導入という大きな拡張を行っており、
リストの構築や可変長引数の取り扱いが劇的に簡略化されました。</p>
<p>最新の Tcl は 8.6 で、更に機能が増えているのですが、まだ Tcl 8.5 が
使われている Distribution もある (ex. CentOS7) ため、本書は Tcl 8.5 で動くことを
基本にします。この前提があるので、 OOP のためのライブラリーには snit を用います。
<small>(snit は Tcl のみで実装されており、かつ古い Tcl 用のバージョンも同梱されています)</small> snit は Tcl の標準ライブラリー集合
tcllib に含まれています。</p>
<p>本書の第二のテーマは、他の言語の感覚で Tcl を書いた時にハマる落とし穴を知ることです。
陥りがちなエラーをエラーメッセージの実例と共に記載します。
Tcl の構文は、所見では他の言語に似て思えることもあります。しかし、他の言語の感覚で書くと
痛い失敗をすることがあります。そのような落とし穴を避けられる基礎体力を得ることも大きな目的です。</p>
<h2><a class="header" href="#筆者について" id="筆者について">筆者について</a></h2>
<p>XXX: TBW</p>
<h2><a class="header" href="#参考リンクなど" id="参考リンクなど">参考リンクなど</a></h2>
<p>XXX: TBW</p>
<h1><a class="header" href="#なぜ今さらtcl" id="なぜ今さらtcl">なぜ今さらTcl?</a></h1>
<p>私が Tcl をお勧めする理由は、Tcl がシェル系の言語の中では（書き方は大分冗長ですが）比較的堅牢なプログラムを書きやすいから、です。付録に <a href="./comparison_with_bash.html">bashとの比較</a> を挙げました。</p>
<p>とはいえ、Tcl で完全に bash(zsh) の置き換えることはお勧めしません。
Tcl の方が書き方が冗長であることや、端末上での REPL でのコマンド補完の仕組みが
劣っていることがその理由です。</p>
<h2><a class="header" href="#もう少し詳しく" id="もう少し詳しく">もう少し詳しく</a></h2>
<p>Tcl がメジャーな言語でないことは、現代の Tcl プログラマーにとって大前提です。
2020-06 の <a href="https://www.tiobe.com/tiobe-index/">TIOBE index</a> における
言語の人気トップ5 は C, Java, Python, C++, C# だそうです。JavaScript が 7位。
<a href="https://www.cleveroad.com/blog/programming-languages-ranking">別の記事</a>での
トップ5 は Python, Java, JavaScript, C#, PHP.</p>
<p>では、一つのお仕事を成し遂げるにあたり、使う言語は一つで良いのでしょうか？
例えば Python や Java, C++ だけで一つの仕事に関わるプログラムを書き上げるのか？というと、
一番外側をシェル系の言語で書くものも見かけます。
例えば linux の firefox や google-chrome, libreoffice の本体は
ネィティブバイナリーですが、それらの起動コマンドが <code>/bin/sh</code> 
で書かれていることはよく知られています。なぜこうするのでしょうか？</p>
<p>勿論、その最も大きな理由は、Linux の Distrubution 間の違いを吸収するためでしょう。
<code>/bin/sh</code> は POSIX 的に必ず使える処理系だからです。
ただ、本当にそれだけが理由でしょうか？ 
クロスプラットフォームな、より優れた言語である python 等の言語を
使わないのは、何故でしょうか？</p>
<p>私の解釈では、そういう仕事はシェル系の言語のほうが楽だから、
という理由もあるのではないかと思います。</p>
<p>複雑な仕事を担うソフトウェアシステムは、他のソフトウェア・要素との
やり取りのために、大量の文字列定数を扱う必要があります。それらは
すなわち、ファイル名やディレクトリ名、データベースへの接続文字列、
クラウドサービスのプロジェクト名やサービスアカウント名、APIキーなどです。</p>
<p>Python や Java などの普通の言語では、文字列定数は全て <code>&quot;...&quot;</code> のように
引用符で表記する必要があります。書くことが面倒という面もありますし、
ハードコーディングを避けたい、オプションとしてプログラムの外から
渡せるようにしたい、という欲求もあります。</p>
<p>それをどこから渡すか。一つには設定ファイルを使う方法があります。
ですが、yaml や ini などの設定ファイルは if や変数、ループは使えません。
プログラムが必要とする文字列定数が一定量を超すと、設定ファイル方式には限界が来ます。
そこでシェル系の言語が導入される、という事情があるように思います。</p>
<p>シェル系の場合、そのシェルのメタ文字でない文字列は、
引用符なしでそのまま表記することが可能です。
また、シェル系の言語はファイル名の操作と、外部プロセスのパイプラインを手短に書ける、
という強みもあります。</p>
<p>そういったシェル系言語として現代で最も使われるのは bash ですが、
初心者が bash で堅牢なプログラムを書くのは決して簡単なことではないように思います。
それに対し Tcl は例外処理の仕組みが整っているので、比較的初心者に優しい言語です。
Unit Test の仕組みも標準添付です。</p>
<p>それが、私が今さら Tcl をお勧めする理由です。</p>
<h1><a class="header" href="#本書の環境" id="本書の環境">本書の環境</a></h1>
<p>同じ環境である必要はありませんが、別の環境の方は細部を自力で読み替えながら進んで下さい。</p>
<ul>
<li>
<p>OS は Fedora Linux を用います(現時点では Fedora32)</p>
<ul>
<li><code>sudo dnf install tcl tcl-doc tcl-html tcllib</code></li>
</ul>
</li>
<li>
<p>Tcl の外側の、POSIXレベルの細かい移植性のための考察は省きます。お好きな人がどうぞ。</p>
</li>
<li>
<p>tclreadline が導入されて、 <code>~/.tclshrc</code> に設定されていることを前提としますが、
無くても多くの例題は実行可能でしょう。</p>
</li>
<li>
<p>Windows や Mac の方は ActiveTcl の wish を使って下さい。</p>
</li>
</ul>
<h2><a class="header" href="#tcl-の起動" id="tcl-の起動">Tcl の起動</a></h2>
<p>本書の例を実行するには、端末から <code>tclsh</code> コマンドを実行して下さい。（バージョンは 8.5 以後なら大丈夫です）</p>
<pre><code class="language-console">% tclsh
</code></pre>
<p>本書では（Tcl の外側の）シェルのプロンプトは <code>% </code> と記載します。
(これは zsh の標準プロンプトです)</p>
<h2><a class="header" href="#コード例と出力の表記方法" id="コード例と出力の表記方法">コード例と出力の表記方法</a></h2>
<p>本書では Tcl コードの例とその実行結果のペアをコードブロックで以下のように記載します。</p>
<pre><code class="language-tcl">コードの例
# =&gt; 実行結果
</code></pre>
<h1><a class="header" href="#tcl-インタープリターと評価のルール" id="tcl-インタープリターと評価のルール">Tcl インタープリターと評価のルール</a></h1>
<p>この章では Tcl インタープリター（Tcl interpreter）の働きについて学びます。
公式マニュアルの <a href="https://www.tcl.tk/man/tcl8.5/TclCmd/Tcl.htm">Tcl の章</a>
に相当する内容です。</p>
<p>Tcl インタープリターとは Tcl プログラムの構造の解釈と実行を司るプログラムで、
その実体は C言語で書かれたライブラリー <a href="https://www.tcl-lang.org/man/tcl8.5/TclLib/Eval.htm">libtcl</a> です。
Tcl の言語エンジンと呼んでも良いでしょう。<code>tclsh</code> や <code>wish</code> も
Tcl インタープリターをライブラリーとして組み込んだシェルです。</p>
<p>Tcl インタープリターは、与えられたプログラムの構造を
Tcl プログラムの書き方のルール（構文論：syntax）に従って読み解き、
それを Tcl プログラムの実行の仕方に関するルール（意味論：semantics）に基づいて実行します。
Tcl では、この２つの過程を合わせて <strong>評価</strong> （evaluation）と呼びます。</p>
<p>Tcl は見かけ上、他のシェルやプログラミング言語に似せた書き方をする所もありますが、
その正確な意味を理解しないままでプログラムを書くと、勘違いによるバグを引き起こすこともあります。
ですので、Tcl インタープリターの挙動を正しく理解することは非常に重要です。</p>
<h2><a class="header" href="#構文を要約するとtcl-のプログラムは" id="構文を要約するとtcl-のプログラムは">構文を要約すると、Tcl のプログラムは：</a></h2>
<ul>
<li>
<p><a href="comment.html"><code>#</code> コメント</a>か、</p>
</li>
<li>
<p><a href="tcl_command.html">コマンド</a>の集まりです。<br />
→ それぞれのコマンドは：</p>
<ul>
<li>
<p>（適切に quote された）<a href="word_breaking_and_quoting.html">word の集まりへと分割</a>されます。<br />
→ それぞれのword の中は：</p>
<ul>
<li>
<p>以下のいずれかの<a href="substitution">置換</a>か、</p>
<ul>
<li>コマンド <code>[]</code> 置換</li>
<li>変数 <code>$</code> 置換</li>
<li>バックスラッシュ <code>\</code> 置換</li>
</ul>
</li>
<li>
<p><small>（word 分割と置換に関わる文字を含まない）</small>只の文字列です。</p>
</li>
</ul>
</li>
<li>
<p>word の先頭が <code>{*}</code> 始まっている場合は、<a href="arg_expansion.html">引数展開</a>が適用されます。</p>
</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#コマンドcommand" id="コマンドcommand">コマンド（command）</a></h1>
<p>Tcl の構文はシェルに似ています。Tcl はプログラムをコマンドの並びとして
解釈し実行します。大まかに言えば、一つのコマンドはコマンド名と引数の並びを
一つ以上の空白文字（スペース又はタブ）で挟んで並べたものです。
<small>（先頭や末尾にも空白文字を入れて構いません）</small>
コマンドの終わりは <strong>改行</strong> か <code>;</code> で表します。</p>
<pre><code class="language-tcl">コマンド名 引数1 引数2...
</code></pre>
<p>コマンドを構成する並びの一つ一つの要素を <strong>word</strong> と呼びます。
例えば以下のコマンドでは <code>string</code>, <code>repeat</code>, <code>foo</code>, <code>3</code> が word です。
<small>（<a href="https://www.tcl.tk/man/tcl8.5/TclCmd/string.htm#M45"><code>string repeat</code></a> は文字列を指定回数だけ繰り返すコマンドです。）</small></p>
<pre><code class="language-tcl">string repeat foo 3
# =&gt; foofoofoo
</code></pre>
<p><strong>word の間の空白文字を省略することは出来ません。</strong>
例えば <code>string repeat foo 1</code> の foo と 1 の間の空白文字を省略したつもりで、
こう書いたとします＞</p>
<pre><code class="language-tcl">string repeat foo1
</code></pre>
<p>結果は次のようなエラーになります。<small>（このエラーはコマンドの引数が足りないことを意味するエラーです。）</small></p>
<pre><code>wrong # args: should be &quot;string repeat string count&quot;
while evaluating {string repeat foo1}
</code></pre>
<p><strong>一行に複数のコマンドを書きたい時は <code>;</code> で区切ります。</strong>
以下は <code>;</code> を使って一行に複数のコマンドを書いた例です。
<small>（<a href="https://www.tcl.tk/man/tcl8.5/TclCmd/puts.htm"><code>puts</code></a> は標準出力に文字列を出力するコマンドです）</small></p>
<pre><code class="language-tcl">puts foo; puts bar
# =&gt; foo
# =&gt; bar
</code></pre>
<h1><a class="header" href="#tclではコマンドという語は多義的に使われます" id="tclではコマンドという語は多義的に使われます">Tclでは、コマンドという語は多義的に使われます</a></h1>
<p>Tcl ではコマンドという語が指すものが文脈によって変化します。</p>
<p>例えば以下のような Tcl プログラムが有ったとします。</p>
<pre><code class="language-tcl">puts foo
string repeat bar 2
</code></pre>
<p>この時、コマンドという語が指すものは、以下の可能性が挙げられます。</p>
<ul>
<li>
<p>コマンド名（この場合は <code>puts</code> 、<code>string</code> あるいは <code>string repeat</code>）</p>
</li>
<li>
<p>その実体、呼ばれて実行されるもの。<small>（ C で実装された <code>Tcl_PutsObjCmd</code>, <code>StringReptCmd</code>）</small></p>
</li>
<li>
<p>引数列も含めた一回の実行コマンド。<small>（<code>puts foo</code> 、 <code>string repeat bar 2</code> それぞれ）</small></p>
</li>
<li>
<p>複数のコマンドの並び <small>（全体）</small></p>
</li>
</ul>
<p>状況に応じて、意味を判断しながら読んで下さい。</p>
<h1><a class="header" href="#word列と-tcl-リスト" id="word列と-tcl-リスト">word列と Tcl リスト</a></h1>
<p>Tcl には Tcl リスト（以後、リストと呼びます）と呼ばれるデータ表現の仕組みがあります。リストは Tcl プログラムの解釈・実行の中で中心的な役割を演じます。というのも、 Tcl インタープリターに入力された一つの word列は、後述の <a href="./substitution.html">置換</a>と<a href="./arg_expansion.html">展開</a>を経て Tcl リストに変換されるからです。</p>
<p>リストは以下のような文字列の並びです</p>
<pre><code>word1 word2 word3...
</code></pre>
<ul>
<li>各 word は、後に説明する <a href="./word_breaking_and_quoting.html">word分割</a>、<a href="./substitution.html">置換</a>、<a href="./arg_expansion.html">展開</a>に関わる文字でない限り、そのまま書くことが出来ます。</li>
<li>そうでない文字を含む word は、<a href="./word_breaking_and_quoting.html">quote</a> される必要があります。</li>
<li>空文字列もリストです。quote 記法で  <code>&quot;&quot;</code>  <code>{}</code> と書きます。</li>
</ul>
<p>リストを構築する一番簡単なコマンドは <code>list</code> です。</p>
<pre><code class="language-tcl">list foo bar   baz
# =&gt; foo bar baz
</code></pre>
<p>もう一つの例として、リストの入った変数に要素を追加する、 <code>lappend</code> コマンドを挙げます。</p>
<pre><code class="language-tcl">lappend x foo bar
# =&gt; foo bar
lappend x baz
# =&gt; foo bar baz
</code></pre>
<p>Tcl のリストは YAML や JSON、S式などのような、シリアライズフォーマットです。
リストを効率的に格納・操作するための内部データ構造とコマンドが揃っています。</p>
<p>これはコマンドを組み立てるコマンドを書くためにリスト操作のコマンド群を活用できることを意味しています。</p>
<h1><a class="header" href="#コメントcomment" id="コメントcomment">コメント（comment）</a></h1>
<p>Tcl でプログラムにコメントを書くには、 <strong>コマンド名の位置の先頭文字に</strong> <code>#</code> を書きます。
これにより行末までがコメントアウトされます。</p>
<pre><code class="language-tcl"># これはコメント
#これもコメント    同じくコメント
   # これもコメント
string repeat これはコマンドの引数 1
</code></pre>
<p>他のプログラミング言語と違って、コマンドの引数の位置に # を書いても、 <strong>単なる # という文字</strong> として扱われてしまうので、注意して下さい。例</p>
<pre><code class="language-tcl">string repeat foo 3 # これは文字列を繰り返すコマンドです、と書くとエラー
</code></pre>
<p>結果は以下↓のように、引数個数間違いのエラーになります。</p>
<pre><code>wrong # args: should be &quot;string repeat string count&quot;
while evaluating {string repeat foo 3 # これは文字列を繰り返すコマンドです、と書くとエラー}
</code></pre>
<p>コマンドの後ろにコメントを続けたい時は、 <code>;#</code> のようにコマンドの終わりを指定して下さい。</p>
<pre><code class="language-tcl">string repeat foo 3;# これは文字列を繰り返すコマンドです
</code></pre>
<h1><a class="header" href="#tcl-インタープリタとコマンドの-word分割" id="tcl-インタープリタとコマンドの-word分割">Tcl インタープリタとコマンドの word分割</a></h1>
<p>ここでコマンドが Tcl に実行される過程を一段階詳しく掘り下げてみましょう。
コマンドは Tcl インタープリターと呼ばれるプログラムによって解釈され、
その結果として <code>string repeat</code> などの具体的な機能が呼び出される仕組みに
なっています。Tcl のプログラムを正しく読み書き出来るためには、
この Tcl インタープリタが果たす役割を理解する必要があります。</p>
<p>Tcl インタープリタは、プログラムを受け取ると、
その字面を流し読みし、空白文字や改行、コメントを見分けます。
そして一回分のコマンドとなる、コマンド名と引数の並びを
（インタープリタの中の、隠されたリストに）格納します。
（以後この作用を <strong>コマンドの word 分割</strong> と呼びます）</p>
<p>その後、そのリストの先頭要素がコマンド名としてコマンド辞書の検索に使われ、
コマンドの実体が取り出されます。
そして最後に、コマンドの実体に対して残りの引数列が渡されます。</p>
<p><small>（Tcl インタープリターには、あと２つ、置換(substitution)と展開(argument expansion)という重要な役割があります）</small></p>
<p><img src="img/tcl_wordbreaking.svg" alt="" /></p>
<h1><a class="header" href="#puts-stdout-文字列" id="puts-stdout-文字列">puts stdout 文字列</a></h1>
<p>先程も使ったように、Tcl で標準出力に文字列を出力するコマンドは <a href="https://www.tcl.tk/man/tcl8.5/TclCmd/puts.htm"><code>puts</code></a> コマンドです。</p>
<pre><code class="language-tcl">puts Hello
# =&gt; Hello
</code></pre>
<p>上記は以下のコマンドの省略形です。標準出力への書き込みであることを指定するために、stdout を渡しています。</p>
<pre><code class="language-tcl">puts stdout Hello
# =&gt; Hello
</code></pre>
<h2><a class="header" href="#全ては文字列-eias---everything-is-a-string" id="全ては文字列-eias---everything-is-a-string">全ては文字列 (EIAS - Everything Is A String)</a></h2>
<p>ここで重要なのは、 <code>stdout</code> という文字列は、
他の言語で言うような予約語ではないことです。 <strong>Tcl に予約語はありません</strong>。
stdout は単なる文字列で、
それ自体に特別な機能はありません。
puts が第一引数を出力先チャネルの名前として扱うに過ぎません。
同じ文字列 stdout を別のコマンド <a href="https://www.tcl.tk/man/tcl8.5/TclCmd/string.htm#M37"><code>string length</code></a> （文字列の長さを測る）や <a href="https://www.tcl.tk/man/tcl8.5/TclCmd/string.htm#M44"><code>string range</code></a> （文字列の指定範囲を取り出す）に渡してみましょう。</p>
<pre><code class="language-tcl">string length stdout
# =&gt; 6
string range stdout 0 2
# =&gt; std
</code></pre>
<p>このように、Tcl では文字列自体に固有の意味というものはありません。
コマンドに渡された文字列にどんな意味を持たせるかは、そのコマンドの自由です。</p>
<h1><a class="header" href="#コマンドのword分割とquote" id="コマンドのword分割とquote">コマンドのword分割とquote</a></h1>
<p>次に <strong>Hello World</strong> と表示したいとします。試しに↓こう書いて実行してみて下さい。</p>
<pre><code class="language-tcl">puts stdout Hello World
</code></pre>
<p>結果は下記↓のように、引数の個数が違う(wrong number of arguments)というエラーになります。</p>
<pre><code class="language-error">wrong # args: should be &quot;puts ?-nonewline? ?channelId? string&quot;
while evaluating {puts stdout Hello World}
</code></pre>
<p>puts コマンドは <small>(-nonewline というオプションを除けば)</small> 出力先チャネル名、そして文字列の２つしか引数を受け付けません。そこに３つの引数を渡したことになり、エラーとされたのです。</p>
<p>このように空白を含んだ文字列を一つの引数として渡したい時は、 
Tcl インタープリタが word分割を行なう時にそれを一つのwordとして
認識してもらえる書き方を用いる必要があります。</p>
<p>スペースを含んだ文字列を一つの word として書く方法は３つあります。
一つはダブルクォート <code>&quot;..&quot;</code> で囲む書き方、
一つは スペースの前にバックスラッシュ <code>\ </code> を使う書き方、
最後の一つは  波括弧(curly brace) <code>{..}</code> で囲む書き方です。</p>
<pre><code class="language-tcl">puts stdout &quot;Hello World&quot;

puts stdout Hello\ World

puts stdout {Hello World}
</code></pre>
<p>最初の２つで書かれた word の中では、次に説明する<a href="./substitution.html">置換</a>
が適用されます。それに対して curly brace 波括弧 <code>{..}</code> で書かれた word は
置換が適用されません。</p>
<h1><a class="header" href="#word内の置換" id="word内の置換">word内の置換</a></h1>
<p>Tcl インタープリターは <a href="./tcl_wordbreaking.html">word 分割</a> が済んだ後の
それぞれの word に対して、置換と呼ばれる以下の処理を施します。
（ただし波括弧 <code>{..}</code> で quote されている word には置換は適用されません）</p>
<h2><a class="header" href="#コマンド置換" id="コマンド置換">コマンド置換</a></h2>
<p>word の中の四角括弧(square bracket) <code>[ .. ]</code> で表された部分は、更に別のコマンドとして実行され、
その結果が元々 <code>[ .. ]</code> のあった個所に差し込まれます。</p>
<pre><code class="language-tcl">puts &quot;length of foo is [string length foo]&quot;
# =&gt; length of foo is 3
</code></pre>
<p>コマンド置換の中も一つのコマンドなので、当然それを入れ子にすることも可能です。</p>
<pre><code class="language-tcl">string repeat [string repeat f 3] 2
# =&gt; ffffff
string length [string repeat [string repeat f 3] 2]
# =&gt; 6
</code></pre>
<h2><a class="header" href="#変数置換" id="変数置換">変数置換</a></h2>
<p>word の中に <code>$</code> で始まる英数字の並びが有れば、それは変数置換の対象となります。
（未知の変数を参照した時は例外が発生し、コマンドの実行はそこで終了します）</p>
<p>変数を作るための最も基本的なコマンドは <a href="https://www.tcl.tk/man/tcl8.5/TclCmd/set.htm"><code>set</code></a> コマンドです。</p>
<pre><code class="language-tcl">set var 5

puts &quot;var is $var&quot;
# =&gt; var is 5
</code></pre>
<h2><a class="header" href="#バックスラッシュ置換" id="バックスラッシュ置換">バックスラッシュ置換</a></h2>
<p>バックスラッシュはコマンド置換の <code>[</code> や変数置換の <code>$</code> などの
文字をそのまま文字列に書きたい時に使います。
また、C 言語に準じた改行文字 <code>\n</code> やタブ文字 <code>\t</code> などの記法も
サポートしています。</p>
<pre><code class="language-tcl">puts &quot;Dollar sign is \$. Open square bracket is \[.&quot;
# =&gt; Dollar sign is $. Open square bracket is [.

puts Open\ curly\ brace\ is\ \{.
# =&gt; Open curly brace is {.
</code></pre>
<h3><a class="header" href="#波括弧-quote--の中では置換は起きないバックスラッシュは-word分割のみに作用" id="波括弧-quote--の中では置換は起きないバックスラッシュは-word分割のみに作用">波括弧 quote <code>{}</code> の中では置換は起きない。バックスラッシュは word分割のみに作用</a></h3>
<p>波括弧quote <code>{}</code> の中では置換が起きません。これはバックスラッシュについても当てはまります。ただしそれ以前の word 分割で、バックスラッシュは <code>{...}</code> の中の
<code>{</code>, <code>}</code> を括弧として数えないためにも使われます。
その場合、バックスラッシュは文字としてそのまま残ります。</p>
<pre><code class="language-tcl">puts {Backslash is kept like \{ and \}.}
# =&gt; Backslash is kept like \{ and \}.
puts {Balanced quote is ok like { and }.}
# =&gt; Balanced quote is ok like { and }.
</code></pre>
<p>これはつまり、波括弧 <code>{...}</code> の中にはバランスした（＝開き括弧と閉じ括弧が正しく対応した）形でしか <code>{</code>, <code>}</code> 文字を書くことが出来ないことを意味します。</p>
<p>括弧の対応を無視して <code>{</code>, <code>}</code> 文字を書きたい時は、ダブルクォート <code>&quot;..&quot;</code> を使います。</p>
<pre><code class="language-tcl">puts &quot;open curly brace {&quot;
# =&gt; open curly brace {
puts &quot;close curly brace }&quot;
# =&gt; close curly brace }
</code></pre>
<h3><a class="header" href="#バックスラッシュを用いた行の継続" id="バックスラッシュを用いた行の継続">バックスラッシュを用いた行の継続</a></h3>
<p>なお、バックスラッシュは改行をコマンドの終わりとしないためにも使えます。
一つのコマンドの行が長くなりすぎた時に行末を <code>\</code> で終わらせると、
そのコマンドの引数の続きを次の行に書くことが出来ます。</p>
<pre><code class="language-tcl">puts [string repeat foo \
  3
]
# =&gt; foofoofoo
</code></pre>
<p>(注！ tclreadline のバージョンによっては↓以下の例がエラーになりますが、
Tcl のプログラムとしては間違いではありません)</p>
<pre><code class="language-tcl">string repeat foo \
  3
# =&gt; foofoofoo
</code></pre>
<h1><a class="header" href="#wordの展開" id="wordの展開">wordの展開</a></h1>
<p>コマンドの中の word が <code>{*}</code> で始まっている場合、word の残る文字列全体が
Tcl のリストとして解釈され、引数のリストに展開されます。
これは可変長の引数を渡したり、複雑な並びを持った Tcl のリストを直接的に
構築するために役立ちます。</p>
<p>以前の節で扱った例を（作為的ですが）展開を使うように書き直した例を以下に挙げます。</p>
<pre><code class="language-tcl">set bar {repeat foo}
string {*}$bar 3
# =&gt; foofoofoo
</code></pre>
<pre><code class="language-tcl">set args [list foo 3]
set cmd [list string repeat {*}$args]
puts $cmd
# =&gt; string repeat foo 3
{*}$cmd
# =&gt; foofoofoo
</code></pre>
<pre><code class="language-tcl">puts {*}{
  stdout
  {Hello world}
}
# =&gt; Hello world
</code></pre>
<h1><a class="header" href="#インタープリタの役割まとめ" id="インタープリタの役割まとめ">インタープリタの役割（まとめ）</a></h1>
<p>以上の <a href="./word_breaking_and_quoting.html">word分割</a>、<a href="./substitution.html">置換</a>、<a href="./arg_expansion.html">展開</a>を一つにまとめるとこの図のようになります。</p>
<p>この図は先のページの例の、 <code>string {*}$bar 3</code> の行を Tcl インタープリターが
解釈する様子を表したものです。</p>
<pre><code class="language-tcl">set bar {repeat foo}
string {*}$bar 3
# =&gt; foofoofoo
</code></pre>
<p><img src="img/tcl_overall.svg" alt="" /></p>
<h1><a class="header" href="#quoteと置換の細かい話" id="quoteと置換の細かい話">quoteと置換の細かい話</a></h1>
<h2><a class="header" href="#波括弧とダブルクォートの違い" id="波括弧とダブルクォートの違い">波括弧とダブルクォートの違い</a></h2>
<pre><code class="language-tcl">set s Hello
puts &quot;The length of $s is [string length $s].&quot;
# =&gt; The length of Hello is 5.

puts {The length of $s is [string length $s].}
# =&gt; The length of $s is [string length $s].
</code></pre>
<h3><a class="header" href="#コマンド置換--は-word-の要素" id="コマンド置換--は-word-の要素">コマンド置換 <code>[..]</code> は word の要素</a></h3>
<pre><code class="language-tcl">puts [string length foo][string length bar]
# =&gt; 33
</code></pre>
<pre><code class="language-tcl">[string repeat puts 1] Hello
# =&gt; Hello
</code></pre>
<h3><a class="header" href="#空のコマンド置換--も正当" id="空のコマンド置換--も正当">空のコマンド置換 <code>[]</code> も正当</a></h3>
<p><code>[]</code> は空の文字列を返すコマンド置換です。</p>
<pre><code class="language-tcl">set s []
# =&gt; 
string length []
# =&gt; 0
</code></pre>
<h3><a class="header" href="#word分割は置換より前に行われる" id="word分割は置換より前に行われる">word分割は置換より前に行われる</a></h3>
<pre><code class="language-tcl">set x 7; set y 9
puts stdout $x+$y=[expr $x + $y]

puts stdout &quot;$x + $y = [expr $x + $y]&quot;
</code></pre>
<h2><a class="header" href="#ダブルクォート波括弧を続けて書くことは禁止" id="ダブルクォート波括弧を続けて書くことは禁止">ダブルクォート・波括弧を続けて書くことは禁止</a></h2>
<p>以下のプログラムは全て word分割の段階で <code>extra characters after close-quote</code> エラーになります。(puts コマンドが実行される前のエラーです)</p>
<pre><code>puts &quot;foo&quot;&quot;bar&quot;

puts &quot;foo&quot;{bar}

puts {foo}{bar}

puts {foo}&quot;bar&quot;

puts {foo}bar
</code></pre>
<h2><a class="header" href="#wordの途中にダブルクォート波括弧を書いても-quote-効果は生じない" id="wordの途中にダブルクォート波括弧を書いても-quote-効果は生じない">wordの途中にダブルクォート・波括弧を書いても quote 効果は生じない</a></h2>
<p>恐るべきことですが、こうなります。</p>
<pre><code class="language-tcl">puts foo{bar

puts foo}bar

puts foo{bar

puts foo&quot;bar

puts foo&quot;bar&quot;

puts foo&quot;bar}
</code></pre>
<pre><code class="language-tcl">set foo --rsync-path=&quot;sudo rsync&quot;
</code></pre>
<pre><code>wrong # args: should be &quot;set varName ?newValue?&quot;
while evaluating {set foo --rsync-path=&quot;sudo rsync&quot;}
</code></pre>
<h1><a class="header" href="#変数手続き計算式制御構文" id="変数手続き計算式制御構文">変数、手続き、計算式、制御構文</a></h1>
<pre><code class="language-tcl">set x 3
# =&gt; 3
set y 8
# =&gt; 8
expr {$x + $y}
# =&gt; 11
puts &quot;$x + $y = [expr {$x + $y}]&quot;
# =&gt; 3 + 8 = 11
</code></pre>
<pre><code class="language-tcl">proc x+y {x y} {
  puts &quot;$x + $y = [expr {$x + $y}]&quot;
}
</code></pre>
<pre><code class="language-tcl">x+y 3 8
# =&gt; 3 + 8 = 11
x+y 5 10
# =&gt; 5 + 10 = 15
</code></pre>
<pre><code class="language-tcl">set x 3
# =&gt; 3
set y 8
# =&gt; 8
expr {$x &lt; $y}
# =&gt; 1
expr {$x &gt;= $y}
# =&gt; 0
proc &lt; {x y} {
  if {$x &lt; $y} {
    puts &quot;$x is less than $y&quot;
  } else {
    puts &quot;$x is greater than or equal to $y&quot;
  }
}

&lt; 3 8
# =&gt; 3 is less than 8
&lt; 8 3
# =&gt; 8 is greater than or equal to 3
</code></pre>
<h1><a class="header" href="#付録" id="付録">付録</a></h1>
<h1><a class="header" href="#bash-と-tcl-の比較" id="bash-と-tcl-の比較">bash と Tcl の比較</a></h1>
<h2><a class="header" href="#構文的特徴" id="構文的特徴">構文的特徴</a></h2>
<table><thead><tr><th></th><th>bash</th><th>tcl</th></tr></thead><tbody>
<tr><td>予約語</td><td>case do done elif else esac fi for function if in select then until while time</td><td>（無し）</td></tr>
<tr><td>コメント</td><td><code>#</code> から行末まで</td><td>コマンド名の位置の <code>#</code> から行末まで(ただし { } が優先される)</td></tr>
<tr><td>他の特殊文字</td><td>| &amp; ; ( ) { } [ ] &lt; &gt; $ ` ! \ * ? =</td><td>; { } [ ] $ \</td></tr>
<tr><td>外部コマンドの起動</td><td>予約語以外は全て外部コマンドと解釈される</td><td>exec, open コマンドを用いて起動<small>(原則)</small></td></tr>
<tr><td>パイプ・リダイレクトの処理</td><td>構文に組み込み | <code>&lt; &gt;</code></td><td>exec, open コマンドの機能</td></tr>
<tr><td>子プロセスの fork</td><td>構文に組み込み <code>( )</code></td><td>外部パッケージ Tclx の fork コマンド</td></tr>
</tbody></table>
<h2><a class="header" href="#言語機能特徴" id="言語機能特徴">言語機能・特徴</a></h2>
<table><thead><tr><th></th><th>bash</th><th>tcl</th></tr></thead><tbody>
<tr><td>プログラムの読み込みと実行の進み方</td><td>一行ずつ読んで実行</td><td>ファイル全体をメモリーに読んだ後で実行</td></tr>
<tr><td>プログラムの動的組み立て</td><td>（自力で）</td><td>コマンドもTclリストなので、list コマンドで組み立てるだけ（ただし AST 操作はない）</td></tr>
<tr><td>制御構文の拡張</td><td>（無し）</td><td>制御構文も一般のコマンド. upvar, uplevel でスコープを制御, return -code で脱出範囲を制御</td></tr>
<tr><td>無名関数</td><td>（無し）</td><td>変数キャプチャーは無いが、list apply コマンドで構築可能</td></tr>
<tr><td>例外処理</td><td>（無し）</td><td>catch コマンド, return コマンド</td></tr>
<tr><td>名前空間</td><td>（無し）</td><td>namespace コマンド</td></tr>
<tr><td>コマンド定義の上書き</td><td>（無し）</td><td>rename コマンドで改名して再定義</td></tr>
<tr><td>変数操作のフック</td><td>（無し）</td><td>trace コマンド</td></tr>
<tr><td>イベントループ</td><td>（無し）</td><td>イベントループが言語組み込み, after コマンドなど</td></tr>
<tr><td>非同期IO</td><td>（プロセスで代用）</td><td>fileevent コマンド</td></tr>
<tr><td>サブインタープリターの使用</td><td>（無し）</td><td>interp コマンド</td></tr>
<tr><td>マルチスレッド</td><td>（無し）</td><td>thread コマンド</td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
