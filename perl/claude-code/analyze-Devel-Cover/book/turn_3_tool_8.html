<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Assistant (Tools 8) - Claude Code に Devel::Cover の真理値表生成の仕組みを解読してもらった</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Claude Code に Devel::Cover の真理値表生成の仕組みを解読してもらった</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ありがとうございますやはり-develcover-は実行時の情報をキャプチャーして活用している"><a class="header" href="#ありがとうございますやはり-develcover-は実行時の情報をキャプチャーして活用している">ありがとうございます。やはり Devel::Cover は実行時の情報をキャプチャーして活用している</a></h1>
<h2 id="tool-interactions"><a class="header" href="#tool-interactions">Tool Interactions</a></h2>
<p><strong>Tool: Write</strong> <code>/home/hkoba/db/monthly/202512/tmp/Devel--Cover/examples/logic_tree_builder.pl</code></p>
<pre><code class="language-perl">#!/usr/bin/env perl
use strict;
use warnings;
use v5.12;

#
# 論理式の木構造を静的に構築するサンプル
# Devel::Cover の手法を参考に、B モジュールで OP ツリーを解析
#

package LogicNode;

# 論理式の木構造を表現するノード

sub new {
    my ($class, %args) = @_;
    return bless \%args, $class;
}

sub type     { $_[0]-&gt;{type} }
sub op       { $_[0]-&gt;{op} }
sub left     { $_[0]-&gt;{left} }
sub right    { $_[0]-&gt;{right} }
sub text     { $_[0]-&gt;{text} }
sub children { @{$_[0]-&gt;{children} // []} }

sub is_leaf {
    my $self = shift;
    return $self-&gt;{type} eq 'leaf';
}

sub to_string {
    my ($self, $indent) = @_;
    $indent //= 0;
    my $pad = "  " x $indent;

    if ($self-&gt;is_leaf) {
        return "${pad}LEAF: $self-&gt;{text}";
    }

    my @lines = ("${pad}$self-&gt;{type} [$self-&gt;{op}]");

    if ($self-&gt;{left}) {
        push @lines, "${pad}  LEFT:";
        if (ref $self-&gt;{left}) {
            push @lines, $self-&gt;{left}-&gt;to_string($indent + 2);
        } else {
            push @lines, "${pad}    $self-&gt;{left}";
        }
    }

    if ($self-&gt;{right}) {
        push @lines, "${pad}  RIGHT:";
        if (ref $self-&gt;{right}) {
            push @lines, $self-&gt;{right}-&gt;to_string($indent + 2);
        } else {
            push @lines, "${pad}    $self-&gt;{right}";
        }
    }

    return join("\n", @lines);
}

#==============================================================================
package LogicTreeBuilder;

use B qw(svref_2object OPf_KIDS);
use B::Deparse;

my %LOGIC_OPS = (
    and       =&gt; { symbol =&gt; '&amp;&amp;',  short_circuit =&gt; 'left_false' },
    andassign =&gt; { symbol =&gt; '&amp;&amp;=', short_circuit =&gt; 'left_false' },
    or        =&gt; { symbol =&gt; '||',  short_circuit =&gt; 'left_true' },
    orassign  =&gt; { symbol =&gt; '||=', short_circuit =&gt; 'left_true' },
    dor       =&gt; { symbol =&gt; '//',  short_circuit =&gt; 'left_defined' },
    dorassign =&gt; { symbol =&gt; '//=', short_circuit =&gt; 'left_defined' },
    xor       =&gt; { symbol =&gt; 'xor', short_circuit =&gt; 'none' },
);

sub new {
    my $class = shift;
    my $self = bless {
        deparse =&gt; B::Deparse-&gt;new('-x7'),  # -x7: 最小限の変形
    }, $class;
    return $self;
}

#------------------------------------------------------------------------------
# コードリファレンスから論理式の木を構築
#------------------------------------------------------------------------------
sub build_from_coderef {
    my ($self, $coderef) = @_;

    my $cv = svref_2object($coderef);
    return unless $cv-&gt;isa('B::CV');

    $self-&gt;{deparse}{curcv} = $cv;
    $self-&gt;{trees} = [];

    my $root = $cv-&gt;ROOT;
    return [] unless $root &amp;&amp; !$root-&gt;isa('B::NULL');

    $self-&gt;_scan_for_logic($root);

    return $self-&gt;{trees};
}

#------------------------------------------------------------------------------
# 論理演算を探して木を構築
#------------------------------------------------------------------------------
sub _scan_for_logic {
    my ($self, $op) = @_;

    return unless $op &amp;&amp; !$op-&gt;isa('B::NULL');

    my $name = $op-&gt;name;

    if (exists $LOGIC_OPS{$name}) {
        my $tree = $self-&gt;_build_logic_tree($op);
        push @{$self-&gt;{trees}}, $tree if $tree;
    } elsif ($name eq 'cond_expr') {
        my $tree = $self-&gt;_build_cond_tree($op);
        push @{$self-&gt;{trees}}, $tree if $tree;
    }

    # 子ノードを再帰的に走査
    if ($op-&gt;flags &amp; OPf_KIDS) {
        for (my $kid = $op-&gt;first; $kid &amp;&amp; !$kid-&gt;isa('B::NULL'); $kid = $kid-&gt;sibling) {
            $self-&gt;_scan_for_logic($kid);
        }
    }
}

#------------------------------------------------------------------------------
# 論理演算の木を構築 (再帰的に部分式も解析)
#------------------------------------------------------------------------------
sub _build_logic_tree {
    my ($self, $op) = @_;

    my $name = $op-&gt;name;
    my $info = $LOGIC_OPS{$name} or return;

    my $left_op = $op-&gt;first;
    return unless $left_op &amp;&amp; !$left_op-&gt;isa('B::NULL');

    my $right_op = $left_op-&gt;sibling;
    return unless $right_op &amp;&amp; !$right_op-&gt;isa('B::NULL');

    # 左辺と右辺を再帰的に解析
    my $left  = $self-&gt;_analyze_operand($left_op);
    my $right = $self-&gt;_analyze_operand($right_op);

    return LogicNode-&gt;new(
        type          =&gt; $name,
        op            =&gt; $info-&gt;{symbol},
        short_circuit =&gt; $info-&gt;{short_circuit},
        left          =&gt; $left,
        right         =&gt; $right,
        right_const   =&gt; $self-&gt;_is_constant($right_op),
    );
}

#------------------------------------------------------------------------------
# 三項演算子の木を構築
#------------------------------------------------------------------------------
sub _build_cond_tree {
    my ($self, $op) = @_;

    my $cond_op = $op-&gt;first;
    return unless $cond_op &amp;&amp; !$cond_op-&gt;isa('B::NULL');

    my $true_op = $cond_op-&gt;sibling;
    my $false_op = $true_op ? $true_op-&gt;sibling : undef;

    return LogicNode-&gt;new(
        type      =&gt; 'cond_expr',
        op        =&gt; '?:',
        condition =&gt; $self-&gt;_analyze_operand($cond_op),
        left      =&gt; $self-&gt;_analyze_operand($true_op),
        right     =&gt; $self-&gt;_analyze_operand($false_op),
    );
}

#------------------------------------------------------------------------------
# オペランドを解析 (論理演算なら再帰、そうでなければ葉ノード)
#------------------------------------------------------------------------------
sub _analyze_operand {
    my ($self, $op) = @_;

    return '' unless $op &amp;&amp; !$op-&gt;isa('B::NULL');

    my $name = $op-&gt;name;

    # 論理演算子なら再帰的に木を構築
    if (exists $LOGIC_OPS{$name}) {
        return $self-&gt;_build_logic_tree($op);
    }

    # null OP の場合は中身を見る
    if ($name eq 'null') {
        my $first = $op-&gt;first;
        if ($first &amp;&amp; !$first-&gt;isa('B::NULL')) {
            my $inner_name = $first-&gt;name;
            if (exists $LOGIC_OPS{$inner_name}) {
                return $self-&gt;_build_logic_tree($first);
            }
        }
    }

    # 葉ノード: deparse してテキストを取得
    return LogicNode-&gt;new(
        type =&gt; 'leaf',
        text =&gt; $self-&gt;_deparse_simple($op),
    );
}

#------------------------------------------------------------------------------
# シンプルな deparse (論理演算子は展開しない)
#------------------------------------------------------------------------------
sub _deparse_simple {
    my ($self, $op) = @_;

    return '' unless $op &amp;&amp; !$op-&gt;isa('B::NULL');

    local $@;
    my $text = eval { $self-&gt;{deparse}-&gt;deparse($op, 0) };
    return $text // '' if $@;

    # 後処理
    $text =~ s/^\s+//;
    $text =~ s/\s+$//;

    return $text;
}

#------------------------------------------------------------------------------
# 定数判定
#------------------------------------------------------------------------------
sub _is_constant {
    my ($self, $op) = @_;

    return 0 unless $op &amp;&amp; !$op-&gt;isa('B::NULL');

    my $name = $op-&gt;name;
    return 1 if $name =~ /^(?:const|undef|s?refgen|null)$/;
    return 1 if $name =~ /^(?:die|return|last|next|redo|goto)$/;
    return 0;
}

#==============================================================================
package TruthTableGenerator;

#------------------------------------------------------------------------------
# LogicNode から真理値表を生成
#------------------------------------------------------------------------------
sub generate {
    my ($class, $node) = @_;

    return [] unless $node;

    if ($node-&gt;is_leaf) {
        return $class-&gt;_leaf_table($node);
    }

    my $type = $node-&gt;type;

    if ($type eq 'cond_expr') {
        return $class-&gt;_cond_table($node);
    }

    # 左右のオペランドの変数を収集
    my @vars = $class-&gt;_collect_variables($node);

    # 左右が複合式かどうかで分岐
    my $left_complex  = ref($node-&gt;left)  &amp;&amp; !$node-&gt;left-&gt;is_leaf;
    my $right_complex = ref($node-&gt;right) &amp;&amp; !$node-&gt;right-&gt;is_leaf;

    if ($left_complex || $right_complex) {
        return $class-&gt;_complex_table($node, \@vars);
    }

    return $class-&gt;_simple_table($node);
}

#------------------------------------------------------------------------------
# 変数を収集
#------------------------------------------------------------------------------
sub _collect_variables {
    my ($class, $node) = @_;

    return () unless $node;

    if ($node-&gt;is_leaf) {
        my $text = $node-&gt;text;
        # $var 形式の変数を抽出
        my @vars = $text =~ /(\$\w+)/g;
        return @vars;
    }

    my @vars;
    push @vars, $class-&gt;_collect_variables($node-&gt;left)  if ref $node-&gt;left;
    push @vars, $class-&gt;_collect_variables($node-&gt;right) if ref $node-&gt;right;

    # 重複を除去しつつ順序を保持
    my %seen;
    return grep { !$seen{$_}++ } @vars;
}

#------------------------------------------------------------------------------
# 単純な真理値表 (and_3, or_3 など)
#------------------------------------------------------------------------------
sub _simple_table {
    my ($class, $node) = @_;

    my $type = $node-&gt;type;
    my $op   = $node-&gt;op;

    my $left_text  = ref($node-&gt;left)  ? $node-&gt;left-&gt;text  : $node-&gt;left;
    my $right_text = ref($node-&gt;right) ? $node-&gt;right-&gt;text : $node-&gt;right;

    my $right_const = $node-&gt;{right_const};

    my @table;

    if ($type =~ /^(?:and|andassign)$/) {
        if ($right_const) {
            # and_2
            @table = (
                { A =&gt; 0, result =&gt; 0, path =&gt; "!$left_text (short-circuit)" },
                { A =&gt; 1, result =&gt; 1, path =&gt; "$left_text" },
            );
        } else {
            # and_3
            @table = (
                { A =&gt; 0, B =&gt; 'X', result =&gt; 0, path =&gt; "!$left_text (short-circuit)" },
                { A =&gt; 1, B =&gt; 0,   result =&gt; 0, path =&gt; "$left_text $op !$right_text" },
                { A =&gt; 1, B =&gt; 1,   result =&gt; 1, path =&gt; "$left_text $op $right_text" },
            );
        }
    } elsif ($type =~ /^(?:or|orassign|dor|dorassign)$/) {
        if ($right_const) {
            # or_2
            @table = (
                { A =&gt; 1, result =&gt; 1, path =&gt; "$left_text (short-circuit)" },
                { A =&gt; 0, result =&gt; 0, path =&gt; "!$left_text" },
            );
        } else {
            # or_3
            @table = (
                { A =&gt; 1, B =&gt; 'X', result =&gt; 1, path =&gt; "$left_text (short-circuit)" },
                { A =&gt; 0, B =&gt; 1,   result =&gt; 1, path =&gt; "!$left_text $op $right_text" },
                { A =&gt; 0, B =&gt; 0,   result =&gt; 0, path =&gt; "!$left_text $op !$right_text" },
            );
        }
    } elsif ($type eq 'xor') {
        # xor_4 (短絡評価なし)
        @table = (
            { A =&gt; 0, B =&gt; 0, result =&gt; 0, path =&gt; "!$left_text xor !$right_text" },
            { A =&gt; 0, B =&gt; 1, result =&gt; 1, path =&gt; "!$left_text xor $right_text" },
            { A =&gt; 1, B =&gt; 0, result =&gt; 1, path =&gt; "$left_text xor !$right_text" },
            { A =&gt; 1, B =&gt; 1, result =&gt; 0, path =&gt; "$left_text xor $right_text" },
        );
    }

    return {
        expression =&gt; "$left_text $op $right_text",
        type       =&gt; $type,
        headers    =&gt; $right_const ? ['A'] : ['A', 'B'],
        rows       =&gt; \@table,
    };
}

#------------------------------------------------------------------------------
# 複合式の真理値表
#------------------------------------------------------------------------------
sub _complex_table {
    my ($class, $node, $vars) = @_;

    # 全変数の組み合わせを生成
    my $n = @$vars;
    my @table;

    for my $i (0 .. (2**$n - 1)) {
        my %vals;
        for my $j (0 .. $n-1) {
            $vals{$vars-&gt;[$j]} = ($i &gt;&gt; ($n - 1 - $j)) &amp; 1;
        }

        my $result = $class-&gt;_evaluate($node, \%vals);
        my @inputs = map { $vals{$_} } @$vars;

        push @table, {
            inputs =&gt; \@inputs,
            result =&gt; $result,
            vals   =&gt; \%vals,
        };
    }

    return {
        expression =&gt; $class-&gt;_node_to_expr($node),
        variables  =&gt; $vars,
        headers    =&gt; [map { s/^\$//r } @$vars],
        rows       =&gt; \@table,
    };
}

#------------------------------------------------------------------------------
# 論理式を評価
#------------------------------------------------------------------------------
sub _evaluate {
    my ($class, $node, $vals) = @_;

    return 0 unless $node;

    if ($node-&gt;is_leaf) {
        my $text = $node-&gt;text;
        # $var 形式を探して値を返す
        if ($text =~ /^\$(\w+)$/) {
            return $vals-&gt;{$text} // 0;
        }
        # 定数として評価
        return $text ? 1 : 0;
    }

    my $type = $node-&gt;type;
    my $left_val  = $class-&gt;_evaluate($node-&gt;left, $vals);
    my $right_val = $class-&gt;_evaluate($node-&gt;right, $vals);

    if ($type =~ /^(?:and|andassign)$/) {
        return $left_val &amp;&amp; $right_val ? 1 : 0;
    } elsif ($type =~ /^(?:or|orassign|dor|dorassign)$/) {
        return $left_val || $right_val ? 1 : 0;
    } elsif ($type eq 'xor') {
        return ($left_val xor $right_val) ? 1 : 0;
    } elsif ($type eq 'cond_expr') {
        my $cond_val = $class-&gt;_evaluate($node-&gt;{condition}, $vals);
        return $cond_val ? $left_val : $right_val;
    }

    return 0;
}

#------------------------------------------------------------------------------
# ノードを式文字列に変換
#------------------------------------------------------------------------------
sub _node_to_expr {
    my ($class, $node) = @_;

    return '' unless $node;

    if ($node-&gt;is_leaf) {
        return $node-&gt;text;
    }

    my $left  = $class-&gt;_node_to_expr($node-&gt;left);
    my $right = $class-&gt;_node_to_expr($node-&gt;right);
    my $op    = $node-&gt;op;

    return "($left $op $right)";
}

#------------------------------------------------------------------------------
# 葉ノード用
#------------------------------------------------------------------------------
sub _leaf_table {
    my ($class, $node) = @_;
    return { expression =&gt; $node-&gt;text, type =&gt; 'leaf', rows =&gt; [] };
}

#------------------------------------------------------------------------------
# 三項演算子用
#------------------------------------------------------------------------------
sub _cond_table {
    my ($class, $node) = @_;

    my $cond_text = ref($node-&gt;{condition}) ? $class-&gt;_node_to_expr($node-&gt;{condition}) : $node-&gt;{condition};
    my $true_text = ref($node-&gt;left) ? $class-&gt;_node_to_expr($node-&gt;left) : $node-&gt;left;
    my $false_text = ref($node-&gt;right) ? $class-&gt;_node_to_expr($node-&gt;right) : $node-&gt;right;

    return {
        expression =&gt; "$cond_text ? $true_text : $false_text",
        type       =&gt; 'cond_expr',
        headers    =&gt; ['cond'],
        rows       =&gt; [
            { cond =&gt; 1, result =&gt; $true_text,  path =&gt; "condition is true" },
            { cond =&gt; 0, result =&gt; $false_text, path =&gt; "condition is false" },
        ],
    };
}

#------------------------------------------------------------------------------
# テキスト形式で出力
#------------------------------------------------------------------------------
sub format_text {
    my ($class, $table) = @_;

    return '' unless $table &amp;&amp; $table-&gt;{rows} &amp;&amp; @{$table-&gt;{rows}};

    my @lines;
    push @lines, "Expression: $table-&gt;{expression}";
    push @lines, "Type: $table-&gt;{type}" if $table-&gt;{type};
    push @lines, "-" x 70;

    my @headers = @{$table-&gt;{headers} // []};

    if ($table-&gt;{variables}) {
        # 複合式
        push @lines, sprintf("| %s | result |", join(" | ", @headers));
        push @lines, "-" x 70;

        for my $row (@{$table-&gt;{rows}}) {
            my $inputs = join(" | ", @{$row-&gt;{inputs}});
            push @lines, sprintf("| %s |   %d    |", $inputs, $row-&gt;{result});
        }
    } else {
        # 単純式
        push @lines, sprintf("| %s | result | path", join(" | ", @headers));
        push @lines, "-" x 70;

        for my $row (@{$table-&gt;{rows}}) {
            my @vals = map { $row-&gt;{$_} // 'X' } @headers;
            my $inputs = join(" | ", @vals);
            push @lines, sprintf("| %s |   %s    | %s",
                $inputs, $row-&gt;{result}, $row-&gt;{path} // '');
        }
    }

    push @lines, "-" x 70;
    return join("\n", @lines);
}

#==============================================================================
package main;

# テスト用サブルーチン
sub test1 { my ($a, $b) = @_; $a &amp;&amp; $b }
sub test2 { my ($a, $b) = @_; $a || $b }
sub test3 { my ($a, $b, $c) = @_; ($a &amp;&amp; $b) || $c }
sub test4 { my ($a, $b, $c) = @_; $a &amp;&amp; ($b || $c) }
sub test5 { my ($a, $b, $c, $d) = @_; ($a || $b) &amp;&amp; ($c || $d) }
sub test6 { my ($x) = @_; $x ? 1 : 0 }

my $builder = LogicTreeBuilder-&gt;new;

print "=" x 70, "\n";
print "Logic Tree Builder - Static Analysis Demo\n";
print "=" x 70, "\n\n";

my @tests = (
    [\&amp;test1, '$a &amp;&amp; $b'],
    [\&amp;test2, '$a || $b'],
    [\&amp;test3, '($a &amp;&amp; $b) || $c'],
    [\&amp;test4, '$a &amp;&amp; ($b || $c)'],
    [\&amp;test5, '($a || $b) &amp;&amp; ($c || $d)'],
    [\&amp;test6, '$x ? 1 : 0'],
);

for my $test (@tests) {
    my ($coderef, $desc) = @$test;

    print "### $desc\n\n";

    my $trees = $builder-&gt;build_from_coderef($coderef);

    for my $tree (@$trees) {
        print "Logic Tree:\n";
        print $tree-&gt;to_string(1), "\n\n";

        my $table = TruthTableGenerator-&gt;generate($tree);
        print TruthTableGenerator-&gt;format_text($table), "\n\n";
    }

    print "-" x 70, "\n\n";
}

</code></pre>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<p><strong>Result:</strong></p>
<pre><code>File created successfully at: /home/hkoba/db/monthly/202512/tmp/Devel--Cover/examples/logic_tree_builder.pl
</code></pre>
<blockquote>
<p>より完成度の高いバージョンを作成しました。実行して結果を確認してみましょう。</p>
</blockquote>
<p><strong>Tool: Bash</strong></p>
<pre><code class="language-json">{
  "command": "perl examples/logic_tree_builder.pl 2&gt;&amp;1",
  "description": "Run logic tree builder"
}
</code></pre>
<h3 id="results-1"><a class="header" href="#results-1">Results</a></h3>
<p><strong>Result:</strong></p>
<pre><code>======================================================================
Logic Tree Builder - Static Analysis Demo
======================================================================

### $a &amp;&amp; $b

Logic Tree:
  and [&amp;&amp;]
    LEFT:
      LEAF: $a
    RIGHT:
      LEAF: $b

Expression: $a &amp;&amp; $b
Type: and
----------------------------------------------------------------------
| A | B | result | path
----------------------------------------------------------------------
| 0 | X |   0    | !$a (short-circuit)
| 1 | 0 |   0    | $a &amp;&amp; !$b
| 1 | 1 |   1    | $a &amp;&amp; $b
----------------------------------------------------------------------

----------------------------------------------------------------------

### $a || $b

Logic Tree:
  or [||]
    LEFT:
      LEAF: $a
    RIGHT:
      LEAF: $b

Expression: $a || $b
Type: or
----------------------------------------------------------------------
| A | B | result | path
----------------------------------------------------------------------
| 1 | X |   1    | $a (short-circuit)
| 0 | 1 |   1    | !$a || $b
| 0 | 0 |   0    | !$a || !$b
----------------------------------------------------------------------

----------------------------------------------------------------------

### ($a &amp;&amp; $b) || $c

Logic Tree:
  or [||]
    LEFT:
      and [&amp;&amp;]
        LEFT:
          LEAF: $a
        RIGHT:
          LEAF: $b
    RIGHT:
      LEAF: $c

Expression: (($a &amp;&amp; $b) || $c)
----------------------------------------------------------------------
| a | b | c | result |
----------------------------------------------------------------------
| 0 | 0 | 0 |   0    |
| 0 | 0 | 1 |   1    |
| 0 | 1 | 0 |   0    |
| 0 | 1 | 1 |   1    |
| 1 | 0 | 0 |   0    |
| 1 | 0 | 1 |   1    |
| 1 | 1 | 0 |   1    |
| 1 | 1 | 1 |   1    |
----------------------------------------------------------------------

Logic Tree:
  and [&amp;&amp;]
    LEFT:
      LEAF: $a
    RIGHT:
      LEAF: $b

Expression: $a &amp;&amp; $b
Type: and
-------------------------------------------
... (truncated)
</code></pre>
<blockquote>
<p>素晴らしい！うまく動作しています。論理式の木構造が正しく解析され、真理値表も生成されています。</p>
<p>ユーザーにサンプルコードの概要と、Devel::Cover との違いを説明しましょう。</p>
</blockquote>
<hr />
<p><small style="color: gray">uuid: assistant: 8f0c2413-893b-437f-85cc-244f015da68c, assistant: 517abd0d-5fd9-40df-8d2e-fc30b432c361, assistant: f4b1e88e-30af-4963-8c7c-ea1a9adb7729, assistant: df1427ae-14f2-423a-a66d-90baea54990f</small></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="turn_3_text_7.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="turn_3_text_9.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="turn_3_text_7.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="turn_3_text_9.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
