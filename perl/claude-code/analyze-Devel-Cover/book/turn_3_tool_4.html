<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Assistant (Tools 4) - Claude Code に Devel::Cover の真理値表生成の仕組みを解読してもらった</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Claude Code に Devel::Cover の真理値表生成の仕組みを解読してもらった</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ありがとうございますやはり-develcover-は実行時の情報をキャプチャーして活用している"><a class="header" href="#ありがとうございますやはり-develcover-は実行時の情報をキャプチャーして活用している">ありがとうございます。やはり Devel::Cover は実行時の情報をキャプチャーして活用している</a></h1>
<h2 id="tool-interactions"><a class="header" href="#tool-interactions">Tool Interactions</a></h2>
<p><strong>Tool: Write</strong> <code>/home/hkoba/db/monthly/202512/tmp/Devel--Cover/examples/static_logic_analyzer.pl</code></p>
<pre><code class="language-perl">#!/usr/bin/env perl
use strict;
use warnings;
use v5.12;

#
# 静的にPerlコードの論理構造を解析し、真理値表を生成するサンプル
# Devel::Cover の手法を参考に、実行せずに B::Deparse で解析
#

package LogicAnalyzer;

use B qw(main_cv svref_2object OPf_KIDS);
use B::Deparse;

# 論理演算子の OP 名
my %LOGIC_OPS = map { $_ =&gt; 1 } qw(and or dor xor andassign orassign dorassign cond_expr);

sub new {
    my $class = shift;
    my $self = bless {
        deparse   =&gt; B::Deparse-&gt;new,
        conditions =&gt; [],  # 検出した条件式
    }, $class;
    return $self;
}

#------------------------------------------------------------------------------
# サブルーチンを解析
#------------------------------------------------------------------------------
sub analyze_sub {
    my ($self, $coderef) = @_;

    my $cv = svref_2object($coderef);
    return unless $cv-&gt;isa('B::CV');

    $self-&gt;{deparse}{curcv} = $cv;
    $self-&gt;{conditions} = [];

    my $root = $cv-&gt;ROOT;
    return unless $root &amp;&amp; !$root-&gt;isa('B::NULL');

    $self-&gt;_walk_op($root);

    return $self-&gt;{conditions};
}

#------------------------------------------------------------------------------
# OP ツリーを再帰的に走査
#------------------------------------------------------------------------------
sub _walk_op {
    my ($self, $op) = @_;

    return unless $op &amp;&amp; !$op-&gt;isa('B::NULL');

    my $name = $op-&gt;name;

    # 論理演算子を検出
    if ($LOGIC_OPS{$name}) {
        my $info = $self-&gt;_analyze_logop($op);
        push @{$self-&gt;{conditions}}, $info if $info;
    }

    # 子ノードを再帰的に走査
    if ($op-&gt;flags &amp; OPf_KIDS) {
        for (my $kid = $op-&gt;first; $kid &amp;&amp; !$kid-&gt;isa('B::NULL'); $kid = $kid-&gt;sibling) {
            $self-&gt;_walk_op($kid);
        }
    }
}

#------------------------------------------------------------------------------
# 論理演算子を解析
#------------------------------------------------------------------------------
sub _analyze_logop {
    my ($self, $op) = @_;

    my $name = $op-&gt;name;
    my $left_op = $op-&gt;first;

    return unless $left_op &amp;&amp; !$left_op-&gt;isa('B::NULL');

    my $right_op;
    if ($name eq 'cond_expr') {
        # 三項演算子: cond ? true : false
        my $cond_op = $left_op;
        my $true_op = $cond_op-&gt;sibling;
        my $false_op = $true_op ? $true_op-&gt;sibling : undef;

        return {
            type      =&gt; 'cond_expr',
            op        =&gt; '?:',
            condition =&gt; $self-&gt;_deparse_op($cond_op),
            true_branch  =&gt; $self-&gt;_deparse_op($true_op),
            false_branch =&gt; $self-&gt;_deparse_op($false_op),
            line      =&gt; $self-&gt;_get_line($op),
        };
    }

    $right_op = $left_op-&gt;sibling;
    return unless $right_op &amp;&amp; !$right_op-&gt;isa('B::NULL');

    my $op_symbol = $self-&gt;_op_to_symbol($name);
    my $left_text  = $self-&gt;_deparse_op($left_op);
    my $right_text = $self-&gt;_deparse_op($right_op);

    # 右辺が定数かどうか判定
    my $right_is_const = $self-&gt;_is_constant($right_op);

    return {
        type       =&gt; $name,
        op         =&gt; $op_symbol,
        left       =&gt; $left_text,
        right      =&gt; $right_text,
        right_const =&gt; $right_is_const,
        line       =&gt; $self-&gt;_get_line($op),
        # 真理値表のタイプを決定
        tt_type    =&gt; $self-&gt;_determine_tt_type($name, $right_is_const),
    };
}

#------------------------------------------------------------------------------
# OP をテキストに変換
#------------------------------------------------------------------------------
sub _deparse_op {
    my ($self, $op) = @_;

    return '' unless $op &amp;&amp; !$op-&gt;isa('B::NULL');

    local $@;
    my $text = eval { $self-&gt;{deparse}-&gt;deparse($op, 0) };
    return '' if $@;

    # 前後の空白を除去
    $text =~ s/^\s+//;
    $text =~ s/\s+$//;

    return $text;
}

#------------------------------------------------------------------------------
# OP 名からシンボルへ
#------------------------------------------------------------------------------
sub _op_to_symbol {
    my ($self, $name) = @_;

    my %symbols = (
        and       =&gt; '&amp;&amp;',
        andassign =&gt; '&amp;&amp;=',
        or        =&gt; '||',
        orassign  =&gt; '||=',
        dor       =&gt; '//',
        dorassign =&gt; '//=',
        xor       =&gt; 'xor',
    );

    return $symbols{$name} // $name;
}

#------------------------------------------------------------------------------
# 定数かどうか判定
#------------------------------------------------------------------------------
sub _is_constant {
    my ($self, $op) = @_;

    return 0 unless $op &amp;&amp; !$op-&gt;isa('B::NULL');

    my $name = $op-&gt;name;

    # const, undef, refgen などは定数扱い
    return 1 if $name =~ /^(?:const|undef|s?refgen|null)$/;

    # die, return, last, next, redo, goto も「評価されない」扱い
    return 1 if $name =~ /^(?:die|return|last|next|redo|goto)$/;

    return 0;
}

#------------------------------------------------------------------------------
# 真理値表タイプを決定
#------------------------------------------------------------------------------
sub _determine_tt_type {
    my ($self, $op_name, $right_is_const) = @_;

    if ($op_name eq 'xor') {
        return 'xor_4';
    } elsif ($op_name =~ /^(?:and|andassign)$/) {
        return $right_is_const ? 'and_2' : 'and_3';
    } elsif ($op_name =~ /^(?:or|orassign|dor|dorassign)$/) {
        return $right_is_const ? 'or_2' : 'or_3';
    }

    return 'unknown';
}

#------------------------------------------------------------------------------
# 行番号を取得
#------------------------------------------------------------------------------
sub _get_line {
    my ($self, $op) = @_;

    # COP (statement) から行番号を取得するのは複雑なので、簡易版
    return 0;  # 実際にはより複雑な処理が必要
}

#==============================================================================
# 真理値表生成
#==============================================================================
package TruthTable;

sub new {
    my ($class, $condition) = @_;
    return bless { condition =&gt; $condition }, $class;
}

sub generate {
    my ($self) = @_;

    my $cond = $self-&gt;{condition};
    my $type = $cond-&gt;{tt_type} // '';

    if ($type eq 'and_3') {
        return $self-&gt;_and_3_table($cond);
    } elsif ($type eq 'and_2') {
        return $self-&gt;_and_2_table($cond);
    } elsif ($type eq 'or_3') {
        return $self-&gt;_or_3_table($cond);
    } elsif ($type eq 'or_2') {
        return $self-&gt;_or_2_table($cond);
    } elsif ($type eq 'xor_4') {
        return $self-&gt;_xor_4_table($cond);
    } elsif ($cond-&gt;{type} eq 'cond_expr') {
        return $self-&gt;_cond_expr_table($cond);
    }

    return [];
}

sub _and_3_table {
    my ($self, $cond) = @_;
    my ($l, $r, $op) = @{$cond}{qw(left right op)};

    return [
        { inputs =&gt; [0, 'X'], result =&gt; 0, desc =&gt; "!($l)" },
        { inputs =&gt; [1, 0],   result =&gt; 0, desc =&gt; "($l) $op !($r)" },
        { inputs =&gt; [1, 1],   result =&gt; 1, desc =&gt; "($l) $op ($r)" },
    ];
}

sub _and_2_table {
    my ($self, $cond) = @_;
    my ($l, $op) = @{$cond}{qw(left op)};

    return [
        { inputs =&gt; [0], result =&gt; 0, desc =&gt; "!($l)" },
        { inputs =&gt; [1], result =&gt; 1, desc =&gt; "($l)" },
    ];
}

sub _or_3_table {
    my ($self, $cond) = @_;
    my ($l, $r, $op) = @{$cond}{qw(left right op)};

    return [
        { inputs =&gt; [1, 'X'], result =&gt; 1, desc =&gt; "($l)" },
        { inputs =&gt; [0, 1],   result =&gt; 1, desc =&gt; "!($l) $op ($r)" },
        { inputs =&gt; [0, 0],   result =&gt; 0, desc =&gt; "!($l) $op !($r)" },
    ];
}

sub _or_2_table {
    my ($self, $cond) = @_;
    my ($l, $op) = @{$cond}{qw(left op)};

    return [
        { inputs =&gt; [1], result =&gt; 1, desc =&gt; "($l)" },
        { inputs =&gt; [0], result =&gt; 0, desc =&gt; "!($l)" },
    ];
}

sub _xor_4_table {
    my ($self, $cond) = @_;
    my ($l, $r) = @{$cond}{qw(left right)};

    return [
        { inputs =&gt; [0, 0], result =&gt; 0, desc =&gt; "!($l) xor !($r)" },
        { inputs =&gt; [0, 1], result =&gt; 1, desc =&gt; "!($l) xor ($r)" },
        { inputs =&gt; [1, 0], result =&gt; 1, desc =&gt; "($l) xor !($r)" },
        { inputs =&gt; [1, 1], result =&gt; 0, desc =&gt; "($l) xor ($r)" },
    ];
}

sub _cond_expr_table {
    my ($self, $cond) = @_;
    my ($c, $t, $f) = @{$cond}{qw(condition true_branch false_branch)};

    return [
        { inputs =&gt; [1], result =&gt; $t, desc =&gt; "($c) ? $t : ..." },
        { inputs =&gt; [0], result =&gt; $f, desc =&gt; "!($c) ? ... : $f" },
    ];
}

sub format_text {
    my ($self) = @_;

    my $table = $self-&gt;generate;
    return '' unless @$table;

    my $cond = $self-&gt;{condition};
    my @lines;

    # ヘッダー
    my $expr = $cond-&gt;{type} eq 'cond_expr'
        ? "$cond-&gt;{condition} ? $cond-&gt;{true_branch} : $cond-&gt;{false_branch}"
        : "$cond-&gt;{left} $cond-&gt;{op} $cond-&gt;{right}";

    push @lines, "Expression: $expr";
    push @lines, "Type: $cond-&gt;{tt_type}" if $cond-&gt;{tt_type};
    push @lines, "-" x 60;

    # 入力ヘッダー
    my $n_inputs = @{$table-&gt;[0]{inputs}};
    my @headers = map { chr(ord('A') + $_) } 0 .. $n_inputs - 1;
    push @lines, sprintf("| %s | Result | Description", join(" | ", @headers));
    push @lines, "-" x 60;

    # 各行
    for my $row (@$table) {
        my $inputs = join(" | ", map { $_ eq 'X' ? 'X' : $_ } @{$row-&gt;{inputs}});
        push @lines, sprintf("| %s |   %s    | %s", $inputs, $row-&gt;{result}, $row-&gt;{desc});
    }

    push @lines, "-" x 60;

    return join("\n", @lines);
}

#==============================================================================
# メイン
#==============================================================================
package main;

# テスト用サブルーチン
sub test_simple_and {
    my ($a, $b) = @_;
    return $a &amp;&amp; $b;
}

sub test_simple_or {
    my ($a, $b) = @_;
    return $a || $b;
}

sub test_or_with_const {
    my ($a) = @_;
    return $a || die "error";
}

sub test_complex {
    my ($a, $b, $c) = @_;
    return ($a || $b) &amp;&amp; $c;
}

sub test_ternary {
    my ($x) = @_;
    return $x ? "yes" : "no";
}

sub test_xor {
    my ($a, $b) = @_;
    return $a xor $b;
}

sub test_dor {
    my ($a, $b) = @_;
    return $a // $b;
}

# 解析実行
my $analyzer = LogicAnalyzer-&gt;new;

print "=" x 60, "\n";
print "Static Logic Structure Analyzer\n";
print "=" x 60, "\n\n";

my @test_subs = (
    [\&amp;test_simple_and,    'test_simple_and:    $a &amp;&amp; $b'],
    [\&amp;test_simple_or,     'test_simple_or:     $a || $b'],
    [\&amp;test_or_with_const, 'test_or_with_const: $a || die'],
    [\&amp;test_complex,       'test_complex:       ($a || $b) &amp;&amp; $c'],
    [\&amp;test_ternary,       'test_ternary:       $x ? "yes" : "no"'],
    [\&amp;test_xor,           'test_xor:           $a xor $b'],
    [\&amp;test_dor,           'test_dor:           $a // $b'],
);

for my $test (@test_subs) {
    my ($coderef, $name) = @$test;

    print "### $name\n\n";

    my $conditions = $analyzer-&gt;analyze_sub($coderef);

    if (@$conditions) {
        for my $cond (@$conditions) {
            my $tt = TruthTable-&gt;new($cond);
            print $tt-&gt;format_text, "\n\n";
        }
    } else {
        print "(No logical conditions found)\n\n";
    }
}

# 文字列からコードを解析するデモ
print "=" x 60, "\n";
print "Analyzing code from string\n";
print "=" x 60, "\n\n";

my $code = q{
    sub complex_logic {
        my ($x, $y, $z) = @_;
        if ($x &amp;&amp; $y || $z) {
            return 1;
        }
        return 0;
    }
};

print "Source code:\n$code\n";

# eval でコードをコンパイル (実行はしない)
eval $code;
if ($@) {
    die "Compile error: $@";
}

my $conditions = $analyzer-&gt;analyze_sub(\&amp;complex_logic);
for my $cond (@$conditions) {
    my $tt = TruthTable-&gt;new($cond);
    print $tt-&gt;format_text, "\n\n";
}

</code></pre>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<p><strong>Result:</strong></p>
<pre><code>File created successfully at: /home/hkoba/db/monthly/202512/tmp/Devel--Cover/examples/static_logic_analyzer.pl
</code></pre>
<blockquote>
<p>サンプルコードを書きました。実行して結果を確認してみましょう。</p>
</blockquote>
<hr />
<p><small style="color: gray">uuid: assistant: f0d2a0ce-018f-4539-8449-18d2c54af0c0, assistant: af324036-ebe7-467e-8151-8f6ec15feccd</small></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="turn_3_text_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="turn_3_text_5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="turn_3_text_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="turn_3_text_5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
